"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.themeTokens = exports.Theme = void 0;

var _components = require("@atlaskit/theme/components");

var componentTokens = _interopRequireWildcard(require("./component-tokens"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var disabledRules = {
  light: {
    backgroundColor: componentTokens.disabledBackground.light,
    backgroundColorFocus: componentTokens.disabledBackground.light,
    backgroundColorHover: componentTokens.disabledBackground.light,
    borderColor: componentTokens.disabledBorder.light,
    borderColorFocus: componentTokens.defaultBorderColorFocus.light,
    textColor: componentTokens.disabledTextColor.light
  },
  dark: {
    backgroundColor: componentTokens.disabledBackground.dark,
    backgroundColorFocus: componentTokens.disabledBackground.dark,
    backgroundColorHover: componentTokens.disabledBackground.dark,
    borderColor: componentTokens.disabledBorder.dark,
    borderColorFocus: componentTokens.defaultBorderColorFocus.dark,
    textColor: componentTokens.disabledTextColor.dark
  }
};
var invalidRules = {
  light: {
    borderColor: componentTokens.invalidBorderColor.light,
    borderColorFocus: componentTokens.defaultBorderColorFocus.light,
    backgroundColor: componentTokens.defaultBackgroundColor.light,
    backgroundColorFocus: componentTokens.defaultBackgroundColorFocus.light,
    backgroundColorHover: componentTokens.defaultBackgroundColorHover.light
  },
  dark: {
    borderColor: componentTokens.invalidBorderColor.dark,
    borderColorFocus: componentTokens.defaultBorderColorFocus.dark,
    backgroundColor: componentTokens.defaultBackgroundColor.dark,
    backgroundColorFocus: componentTokens.defaultBackgroundColorFocus.dark,
    backgroundColorHover: componentTokens.defaultBackgroundColorHover.dark
  }
};
var backgroundColor = {
  standard: componentTokens.defaultBackgroundColor,
  subtle: componentTokens.transparent,
  none: componentTokens.transparent
};
var backgroundColorFocus = {
  standard: componentTokens.defaultBackgroundColorFocus,
  subtle: componentTokens.defaultBackgroundColorFocus,
  none: componentTokens.transparent
};
var backgroundColorHover = {
  standard: componentTokens.defaultBackgroundColorHover,
  subtle: componentTokens.subtleHoverBackgroundColor,
  none: componentTokens.transparent
};
var borderColor = {
  standard: componentTokens.defaultBorderColor,
  subtle: componentTokens.transparent,
  none: componentTokens.transparent
};
var borderColorFocus = {
  standard: componentTokens.defaultBorderColorFocus,
  subtle: componentTokens.defaultBorderColorFocus,
  none: componentTokens.transparent
};
var themeTokens = {
  borderColor: borderColor,
  borderColorFocus: borderColorFocus,
  backgroundColor: backgroundColor,
  backgroundColorFocus: backgroundColorFocus,
  backgroundColorHover: backgroundColorHover,
  disabledRules: disabledRules,
  invalidRules: invalidRules,
  textColor: componentTokens.textColor,
  placeholderTextColor: componentTokens.placeholderTextColor
};
exports.themeTokens = themeTokens;
var Theme = (0, _components.createTheme)(function (_ref) {
  var appearance = _ref.appearance,
      mode = _ref.mode;
  return {
    borderColor: borderColor[appearance][mode],
    borderColorFocus: borderColorFocus[appearance][mode],
    backgroundColorHover: backgroundColorHover[appearance][mode],
    backgroundColorFocus: backgroundColorFocus[appearance][mode],
    backgroundColor: backgroundColor[appearance][mode],
    disabledRules: disabledRules[mode],
    invalidRules: invalidRules[mode],
    textColor: componentTokens.textColor[mode],
    placeholderTextColor: componentTokens.placeholderTextColor[mode]
  };
});
exports.Theme = Theme;