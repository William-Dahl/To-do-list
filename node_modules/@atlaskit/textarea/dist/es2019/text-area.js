import _extends from "@babel/runtime/helpers/extends";

/** @jsx jsx */
import React, { forwardRef, memo, useCallback, useEffect, useMemo, useRef } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import GlobalTheme from '@atlaskit/theme/components';
import { borderWidth, getBaseStyles, themeStyles } from './styles';
import { Theme } from './theme';
const packageName = "@atlaskit/textarea";
const packageVersion = "4.3.1";
const analyticsParams = {
  componentName: 'textArea',
  packageName,
  packageVersion
};

const setSmartHeight = el => {
  // Always reset height to auto before calculating new height
  el.style.height = 'auto';
  const borderHeight = borderWidth;
  const paddingBoxHeight = el.scrollHeight;
  const borderBoxHeight = paddingBoxHeight + borderHeight * 2;
  el.style.height = `${borderBoxHeight}px`;
};

const TextAreaWithTokens = /*#__PURE__*/forwardRef((props, ref) => {
  const ourRef = useRef(null);
  const {
    resize = 'smart',
    appearance = 'standard',
    isCompact = false,
    isRequired = false,
    isReadOnly = false,
    isDisabled = false,
    isInvalid = false,
    isMonospaced = false,
    minimumRows = 1,
    theme,
    testId,
    maxHeight = '50vh',
    onBlur,
    onFocus,
    onChange,
    tokens,
    value,
    ...rest
  } = props;
  useEffect(() => {
    const el = ourRef.current;

    if (resize === 'smart' && el) {
      setSmartHeight(el);
    }
  }, [resize, value]);
  const onBlurWithAnalytics = usePlatformLeafEventHandler({
    fn: event => {
      onBlur && onBlur(event);
    },
    action: 'blurred',
    ...analyticsParams
  });
  const onFocusWithAnalytics = usePlatformLeafEventHandler({
    fn: event => {
      onFocus && onFocus(event);
    },
    action: 'focused',
    ...analyticsParams
  });

  const getTextAreaRef = elementRef => {
    ourRef.current = elementRef;

    if (ref && typeof ref === 'object') {
      // @ts-ignore
      ref.current = elementRef;
    }

    if (ref && typeof ref === 'function') {
      ref(elementRef);
    }
  };

  const handleOnChange = useCallback(e => {
    const el = ourRef.current;

    if (resize === 'smart' && el) {
      setSmartHeight(el);
    }

    onChange && onChange(e);
  }, [onChange, resize]);
  const controlProps = {
    'data-invalid': isInvalid ? isInvalid : undefined,
    'data-compact': isCompact ? isCompact : undefined,
    'data-testid': testId ? testId : undefined
  };
  const baseStyles = useMemo(() => getBaseStyles({
    minimumRows,
    resize,
    appearance,
    isMonospaced,
    maxHeight
  }), [minimumRows, resize, appearance, isMonospaced, maxHeight]);
  const textAreaStyles = [baseStyles, // not memoizing themeStyles as `tokens` is an unstable reference
  themeStyles(tokens)];
  return jsx("textarea", _extends({}, controlProps, {
    value: value,
    disabled: isDisabled,
    readOnly: isReadOnly,
    required: isRequired,
    ref: getTextAreaRef,
    onChange: handleOnChange,
    onBlur: onBlurWithAnalytics,
    onFocus: onFocusWithAnalytics // TODO refactor to follow emotion styling rules
    // eslint-disable-next-line @repo/internal/react/consistent-css-prop-usage
    ,
    css: textAreaStyles
  }, rest));
});
const TextArea = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function TextArea(props, ref) {
  return jsx(GlobalTheme.Consumer, null, ({
    mode
  }) => jsx(Theme.Provider, {
    value: props.theme
  }, jsx(Theme.Consumer, {
    appearance: props.appearance || 'standard',
    mode: mode
  }, tokens => jsx(TextAreaWithTokens, _extends({
    ref: ref
  }, props, {
    tokens: tokens
  })))));
}));
TextArea.displayName = 'TextArea';
export default TextArea;